# 数据库知识-系统篇

## 事务

> 一组操作序列，要么全做，要么全不做

- commit提交
- rollback回滚

### ACID特性

- Atomicity：原子性
- Consistency：一致性
- Isolation：隔离性
- Durability：持久性

## 并发控制

- 事务是并发控制的基本单位

### 数据的不一致性

#### 1. 丢失修改（lost update）

- 两事务同时读入数据并修改，第二个事务破坏了第一个事务提交的结果，导致第一个事务的修改被丢失

#### 2. 不可重复读（non-repeated read）

- 第一个事务读取数据后，第二个事务修改了数据，导致第一个事务第二次读取的数据与第一次不同
- 第一个事务读取数据后，第二个事务删除了数据，导致第一个事务再次读取时发现数据神秘的消失了
- 第一个事务读取数据后，第二个事务插入了一些数据，导致第一个事务再次读取时，发现多了一些数据

> 其中后两种不可重复读也被称为幻影（phantom row）现象

#### 3. 读“脏”数据（dirty read）

- 事务T1修改数据后，事务T2读取同一数据，然后T1因某种原因被撤销，导致T2读取的数据与数据库中的数据不一致

### 封锁

#### 基本锁类型

- 排他锁（exclusive locks，简称X锁）：又称写锁
- 共享锁（share locks，简称S锁）：又称读锁

#### 三级封锁协议

##### 1. 一级封锁协议

> 事务在修改数据时必须加X锁

- 可防止丢失修改

##### 2. 二级封锁协议

> 事务在一级封锁协议的基础上；在读取数据前，必须加S锁，读完即可释放S锁

- 可防止丢失修改
- 可防止读“脏数据”

##### 3. 三级封锁协议

> 事务在一级封锁协议的基础上；在读取数据前，必须加S锁，事务结束才可释放S锁

- 可防止丢失修改
- 可防止读“脏”数据
- 可防止不可重复读

#### 死锁

##### 死锁的诊断

- 超时法
- 事务等待图法

##### 死锁的解除

- 通常采用的方法是选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁

#### 并发调度的可串行性

> 多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同，称这种调度策略为**可串行化（serializable）调度**
>
> **可串行性serializability**是并发事务正确调度的准则

#### 封锁的粒度

> 封锁对象的大小称为**封锁粒度（granularity）**

##### 多粒度封锁

- 显式封锁：直接加到数据对象上的锁
- 隐式封锁：由于其上级结点加锁而导致该对象加上了锁

##### 意向锁

> **intention lock**，如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁
>
> 一般地，对某个对象加锁，不及要检查该对象的显式封锁和隐式封锁，还要检查其所有下级结点的显式封锁与本事务的隐式封锁是否冲突，而**意向锁**正是为了解决这个问题。

- IS锁：Intent Share Lock，意向共享锁
- IX锁：Intent Exclusive Lock，意向排他锁
- SIX锁：Share Intent Exclusive Lock，共享意向排他锁
